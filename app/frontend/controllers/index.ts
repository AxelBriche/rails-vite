// This file is auto-generated by ./bin/rails stimulus:manifest:update
// Run that command whenever you add a new controller or create them with
// ./bin/rails generate stimulus controllerName

import { application } from "./application"
import { Controller } from "@hotwired/stimulus"

/* Permet l'auto-import de tous les controllers stimulus dont le nom se termine par _controller.ts */
type ControllerModule = { default: typeof Controller }

// Changement du type de retour du glob
const allFiles = import.meta.glob<ControllerModule | Record<string, unknown>>('./**/*', { eager: true })

Object.entries(allFiles).forEach(([path, controller]) => {
  if (path === './application.ts') return
  
  if (!path.endsWith('_controller.ts')) {
    throw new Error(`Le fichier "${path}" n'est pas un contrôleur valide. Les fichiers doivent se terminer par '_controller.ts'`)
  }

  // Vérifie que le nom est en snake_case (lettres minuscules + chiffres, séparés par des underscores simples)
  const fileNameMatch = path.match(/\.\/(.+)_controller\./)
  if (fileNameMatch && !/^[a-z0-9]+(?:_[a-z0-9]+)*$/.test(fileNameMatch[1])) {
    throw new Error(`Le nom du fichier "${path}" doit être en snake_case (uniquement des lettres minuscules et des chiffres, séparés par des underscores simples). Exemple valide: mon_super_controller.ts`)
  }

  const match = path.match(/\.\/(.+)_controller\./)
  const name = match?.[1]?.replace(/\//g, '--')

  if (!name) {
    throw new Error(`Controller path "${path}" ne correspond pas au format attendu`)
  }

  if (!('default' in controller)) {
    throw new Error(`Controller "${name}" doit avoir un export default class qui étend Controller`)
  }

  application.register(name, (controller as ControllerModule).default)
})
